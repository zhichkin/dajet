## DaJet Script

[Начало](https://github.com/zhichkin/dajet/tree/main/doc/dajet-script/README.md)

### Преобразование типов данных

> Доступно, начиная с версии DaJet 3.11.2

Преобразование типов данных выполняется в **DaJet Script** при помощи функции ```CAST```, аналогично стандартному синтаксису **SQL**. Функция возвращает значение, указанного после ключевого слова **AS**, типа данных. Преобразование выполняется согласно нижеследующей таблице приводимости типов данных.

```SQL
CAST(<expression> AS <target_type>)
```
[Подробная информация о системе типов данных DaJet Script](https://github.com/zhichkin/dajet/blob/main/doc/dajet-script/data-type-system/README.md)

**\<expression\>** - выражение DaJet Script, обычно переменная или обращение к свойству объекта.<br>
**\<target_type\>** - тип данных, к которому необходимо привести значение выражения. Допустимые значения:
- ```boolean```
- ```integer``` (целое число)
- ```decimal``` (синоним для ```number```)
- ```datetime```
- ```string```
- ```binary```
- ```uuid```
- ```entity```

**Таблица преобразования типов данных**

> В колонке "Тип данных" указан исходный тип данных. Заголовки последующих колонок указывают на целевой тип данных, к которому можно преобразовать значение исходного типа данных. В ячейках пересечения указывается возможность такого преобразования, формат получаемого значения. Если ячейка не заполнена, то выполненеие преобразования типа невозможно.

|Тип<br>данных|**union**|**boolean**|**integer**|**decimal**|**datetime**|**string**|**entity**|**uuid**|**binary**|
|---|---|---|---|---|---|---|---|---|---|
|**union**||+|+|+|+|+|+|||
|**boolean**|||1 или 0|||"true"<br>"false"|||0x01<br>0x00|
|**integer**||true != 0<br>false == 0||+|Секунды от<br>01.01.0001|+|||big<br>endian|
|**decimal**|||Целая часть<br>без округления|||+||||
|**datetime**|||Секунды от<br>01.01.0001|||ISO-8601||||
|**string**||true<br>false|+|+|ISO-8601||+|+|UTF-8|
|**entity**||||||{int:uuid}||||
|**uuid**||||||+|||+|
|**binary**||true<br>false|big<br>endian|||UTF-8||+||

> Тип данных ```string``` является универсальным типом данных в том смысле, что любой другой тип данных может быть выражен через него и преобразован обратно. Кроме этого следует иметь ввиду, что многие типы данных имеют в DaJet Script специальные литералы, которые преобразуются парсером языка в целевой тип автоматически.

[Наверх](#преобразование-типов-данных)

#### Преобразование составного типа данных ```union```

В данном примере важно обратить внимание на то, что преобразование составного типа данных ```union``` будет успешно выполняться только в том случае, когда конкретное значение ```union``` содержит целевой тип данных. В противном случае будет выдана ошибка. Таким образом, предварительно выполняется анализ значения ```union``` на содержащийся в нём тип данных при помощи функции **TYPEOF**.

```SQL
DEFINE Запись(Код string, ПолныйСоставнойТип union)

DECLARE @array array OF Запись
DECLARE @object object
DECLARE @type string
DECLARE @union union

USE 'mssql://server/database'
   SELECT Код, ПолныйСоставнойТип INTO @array
     FROM Справочник.Тестовый ORDER BY Код ASC
END --USE

FOR @object IN @array

   SET @union = @object.ПолныйСоставнойТип
   SET @type  = TYPEOF(@object.ПолныйСоставнойТип)

   MODIFY @object DELETE ПолныйСоставнойТип
   SELECT ТипДанных = @type, Значение = CASE
     WHEN @type = 'undefined' THEN 'Неопределено'
     WHEN @type = 'boolean'   THEN CAST(CAST(@union AS boolean)  AS string)
     WHEN @type = 'number'    THEN CAST(CAST(@union AS decimal)  AS string) -- CAST(@union AS integer)
     WHEN @type = 'datetime'  THEN CAST(CAST(@union AS datetime) AS string)
     WHEN @type = 'string'    THEN CAST(CAST(@union AS string)   AS string)
     WHEN @type = 'entity'    THEN CAST(CAST(@union AS entity)   AS string)
     ELSE 'Неизвестный тип: [' + @type + ']'
   END --CASE

END --FOR

RETURN @array
```

[Наверх](#преобразование-типов-данных)

#### Анализ типа данных регистратора

В данном примере для анализа типа данных регистратора используется вспомогательная переменная ```СсылкаРегистратора```. Несмотря на то, что тип данных поля регистра накопления **Регистратор** чаще всего имеет составной тип данных ```union```, исторически так сложилось, что DaJet, оптимизируя работу с базой данных, загружает такие значения как тип данных ```entity```. Таким образом это приводит к конфликту между логикой загрузки значений из базы данных и новым функционалом **DaJet Script** при поиске функции **TYPEOF**, **NAMEOF** или **CAST** с нужной сигнатурой (эти функции перегружены и имеют несколько вариантов использования в зависимости от типа данных входных параметров).

```SQL
DECLARE @НаборЗаписей array
DECLARE @ЗаписьРегистра object
DECLARE @ТипРегистратора string
DECLARE @СсылкаРегистратора entity

USE 'mssql://server/database'

   SELECT ВидДвижения, Регистратор
        , Номенклатура, Количество
     INTO @НаборЗаписей
     FROM РегистрНакопления.ЗапасыНаСкладах

   FOR @ЗаписьРегистра IN @НаборЗаписей

      SET @СсылкаРегистратора = @ЗаписьРегистра.Регистратор
      SET @ТипРегистратора = NAMEOF(@СсылкаРегистратора)

      MODIFY @ЗаписьРегистра
      SELECT ТипДокумента = @ТипРегистратора
   END
END

RETURN @НаборЗаписей
```

[Наверх](#преобразование-типов-данных)

#### Анализ типа узла таблицы регистрации изменений плана обмена

Данный пример аналогичен анализу типа данных регистратора. Объяснение использования вспомогательной переменной здесь такое же.

```SQL
DEFINE Запись(УзелОбмена union, Ссылка entity)

DECLARE @array array OF Запись
DECLARE @object object
DECLARE @entity entity
DECLARE @ИмяПланаОбмена string

USE 'mssql://server/database'
   
   SELECT УзелОбмена, Ссылка INTO @array
     FROM Справочник.Тестовый.Изменения

   FOR @object IN @array

      SET @entity = @object.УзелОбмена
      SET @ИмяПланаОбмена = NAMEOF(@entity)

      MODIFY @object
      SELECT ТипПланаОбмена = TYPEOF(@entity)
           , ИмяПланаОбмена = @ИмяПланаОбмена
   END --FOR 
END --USE

RETURN @array
```

[Наверх](#преобразование-типов-данных)
