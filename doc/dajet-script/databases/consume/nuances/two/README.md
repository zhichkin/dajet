## DaJet Script

[CONSUME](https://github.com/zhichkin/dajet/tree/main/doc/dajet-script/databases/consume/README.md)

### Команда CONSUME, нюанс SQL Server

Прежде, чем читать эту статью, следует ознакомиться со статьёй [Команда CONSUME, нюанс № 1](https://github.com/zhichkin/dajet/blob/main/doc/dajet-script/databases/consume/nuances/one/README.md).

Данная статья освещает использование команды **CONSUME** без опции ```WITH STRICT ORDER``` исключительно в среде Microsoft SQL Server. Дело в том, что у хинта ```READPAST``` есть занятная особенность в поведении, которая очень трудна для воспроизведения в условиях промышленной эксплуатации обменов данными. Более того её сложно воспроизвести даже в лабораторных условиях.

Для демонстрации примера будет использована Microsoft SQL Server Management Studio. Работа с базой данных 1С:Предприятие 8 будет выполняться в режиме управляемых блокировок, то есть у базы данных будет включена опция ```read committed snapshot```. Структура регистра взята из примера "Нюанс № 1".

> Все ниже следующие скрипты выполняются по таймеру, взведённому на определённое время - команда ```WAITFOR TIME```. Для воспроизведения следует подобрать соответствующее значение времени согласно текущему времени на своём компьютере. Если у вас ничего не получится, то не расстраивайтесь - это трудно уловимое поведение. Попробуйте повторить сценарий несколько раз.

**Шаг 1.** Транзакция A: откроем новую панель запросов и выполним следующий код SQL. Этот код добавляет 10 000 сообщений в таблицу-очередь, а затем ждёт установленного времени, чтобы зафиксировать транзакцию. Итогом выполнения скрипта будет "подвисание" панели запросов до указанного времени.

```SQL
DECLARE @counter numeric(15,0) = 0;

BEGIN TRANSACTION;

WHILE @counter < 10000 BEGIN

   SET @counter = @counter + 1;

   INSERT _InfoRg123 SELECT @counter, '', '';

END;

WAITFOR TIME '12:00:00.001';

COMMIT TRANSACTION;
```

**Шаг 2.** Транзакция B: откроем новую панель запросов и выполним следующий код SQL. Этот код эмулирует выполнение команды **CONSUME** без опции ```WITH STRICT ORDER```. Скрипт начнёт своё выполнение в установленное время.

Ожидаемый итог выполнения скрипта:
- Успешная обработка 10 000 записей, добавленных в очередь транзакцией A, в том случае если транзакция A успеет зафиксироваться.
- Обработка нуля записей из-за того, что сообщения заблокированы всё той же транзакцией A и она ещё не успела зафиксироваться.

```SQL
WAITFOR TIME '12:00:00.000';

WITH queue AS 
(SELECT TOP (10000)
        _Fld124 AS НомерСообщения,
        _Fld125 AS ТипСообщения,
        _Fld126 AS ТелоСообщения
   FROM _InfoRg123 WITH (ROWLOCK, READPAST)
  ORDER BY _Fld124 ASC)
DELETE queue
OUTPUT deleted.НомерСообщения,
       deleted.ТипСообщения,
       deleted.ТелоСообщения;
```

**Шаг 3.** Транзакция C: откроем новую панель запросов и выполним следующий код SQL. Просто убеждаемся, что все сообщения помещены в очередь. Использование хинта ```NOLOCK``` в данном случае обязательно, иначе ничего не увидим, так как транзакция A ещё не зафиксировалась.

```SQL
SELECT _Fld124 AS НомерСообщения,
       _Fld125 AS ТипСообщения,
       _Fld126 AS ТелоСообщения
  FROM _InfoRg123 WITH (NOLOCK);
```

**Шаг 4.** Дожидаемся наступления установленного времени и окончательного выполнения скриптов.

**Результат выполнения скрипта шага № 2**

![Результат обработки очереди](https://github.com/zhichkin/dajet/blob/main/doc/img/sql-server-consume-nuance-04.png)

Что мы видим ? Из двух ожидаемых результатов мы получили третий! Обработано всего 3952 записи ... да ещё и с конца очереди ... Нарушена последовательсность обработки записей, которые фиксировались **в одной и той же транзакции** !!!

**Объяснение**

Всё дело в том, что, как мы уже знаем из статьи "Нюанс № 1", хинт ```READPAST``` позволяет пропускать заблокированные записи и обрабатывать следующие за ними по порядку незаблокированные. SQL Server обрабатывает для транзакции B, выбираемые запросом записи, по сути своей сканируя кластерный индекс согласно направлению оределённой пользователем сортировки. Таким образом на начало сканирования транзакция A ещё не зафиксировала все свои изменения, но уже начала это делать. В это же самое время транзакция B пытается обработать те же самые записи и успевает пропустить первые 6048, и именно в этот момент транзакция A фиксируется полность. Теперь транзакции B становятся доступны следующие 3952 записи в хвосте очереди... Занавес.

**Что делать ?**

Первое и самое главное: поменьше регистрировать сообщений в таблице-очереди в рамках одной транзакции. Данный "нюанс" не удалось воспроизвести на 1000 записей - слишком всё быстро происходит. Вероятно за наносекунды. Не поймать.

Практичное второе: на практике это очень-очень-очень редко имеет значение и последствия.

Тем не менее (в порядке наиболее рационального и практичного):
1. Рассмотреть использование опции ```WITH STRICT ORDER```.
2. Перейти с Microsoft SQL Server на PostgreSQL.
3. Использовать SQL Server CDC (change data capture).
4. Использовать подсистему SQL Server Service Broker.

[Наверх](#команда-consume-нюанс-sql-server)
